<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
    <html>
      <head>
        <meta charset='utf-8'>
        <meta http-equiv="X-UA-Compatible" content="chrome=1">
        <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
        <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
        <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
        <!--[if lt IE 9]>
        <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
        <title>DlangUI - cross platform GUI library for D programming language - dlangui.widgets.widget</title>
      </head>
      <body>
        <div id="container">
          <div class="inner">
            <header>
              <h1>DlangUI</h1>
              <h2>Cross Platform GUI for D programming language</h2>
            </header>
            <section id="downloads" class="clearfix">
              <a href="index.html" id="home" class="button"><span>Home</span></a>
              <a href="api.html" id="home" class="button"><span>API Docs</span></a>
              <a href="screenshots.html" id="home" class="button"><span>Screenshots</span></a>
              <a href="https://github.com/buggins/dlangui/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
              <!--a href="https://github.com/buggins/dlangui/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a-->
              <a href="https://github.com/buggins/dlangui" id="view-on-github" class="button"><span>View on GitHub</span></a>
            </section>

            <hr>
            <section id="main_content">
	            <h1>dlangui.widgets.widget</h1>
	            <!-- Generated by Ddoc from src\dlangui\widgets\widget.d -->
This module contains declaration of Widget class - base class for all widgets.
<br><br>
Widgets are styleable. Use styleId property to set style to use from current Theme.
<br><br>

When any of styleable attributes is being overriden, <u>widget</u>'s own copy of style is being created to hold modified attributes (defaults to parent style).
<br><br>

Two phase layout model (like in Android UI) is used - measure() call is followed by layout() is used to measure and layout <u>widget</u> and its children.abstract
<br><br>

Method onDraw will be called to draw <u>widget</u> on some surface. Widget.onDraw() draws <u>widget</u> background (if any).
<br><br>


<br><br>
<b>Synopsis:</b><br>
<pre class="d_code"><font color=blue>import</font> dlangui.widgets.<u>widget</u>;

<font color=green>// access attributes as properties
</font><font color=blue>auto</font> w = <font color=blue>new</font> Widget(<font color=red>"id1"</font>);
w.backgroundColor = 0xFFFF00;
w.layoutWidth = FILL_PARENT;
w.layoutHeight = FILL_PARENT;
w.padding(Rect(10,10,10,10));
<font color=green>// same, but using chained method call
</font><font color=blue>auto</font> w = <font color=blue>new</font> Widget(<font color=red>"id1"</font>).backgroundColor(0xFFFF00).layoutWidth(FILL_PARENT).layoutHeight(FILL_PARENT).padding(Rect(10,10,10,10));


</pre>

<br><br>
<b>License:</b><br>
Boost License 1.0
<br><br>
<b>Authors:</b><br>
Vadim Lopatin, coolreader.org@gmail.com<br><br>

<dl><dt><big><a name="Visibility"></a>enum <u>Visibility</u>: ubyte;
</big></dt>
<dd><u>Visibility</u> (see Android View <u>Visibility</u>)<br><br>

<dl><dt><big><a name="Visibility.Visible"></a><u>Visible</u></big></dt>
<dd><u>Visible</u> on screen (default)<br><br>

</dd>
<dt><big><a name="Visibility.Invisible"></a><u>Invisible</u></big></dt>
<dd>Not visible, but occupies a space in layout<br><br>

</dd>
<dt><big><a name="Visibility.Gone"></a><u>Gone</u></big></dt>
<dd>Completely hidden, as not has been added<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="OnClickHandler"></a>interface <u>OnClickHandler</u>;
</big></dt>
<dd>interface - slot for onClick<br><br>

</dd>
<dt><big><a name="OnCheckHandler"></a>interface <u>OnCheckHandler</u>;
</big></dt>
<dd>interface - slot for onCheckChanged<br><br>

</dd>
<dt><big><a name="OnFocusHandler"></a>interface <u>OnFocusHandler</u>;
</big></dt>
<dd>interface - slot for onFocusChanged<br><br>

</dd>
<dt><big><a name="OnKeyHandler"></a>interface <u>OnKeyHandler</u>;
</big></dt>
<dd>interface - slot for onKey<br><br>

</dd>
<dt><big><a name="OnMouseHandler"></a>interface <u>OnMouseHandler</u>;
</big></dt>
<dd>interface - slot for onMouse<br><br>

</dd>
<dt><big><a name="FocusMovement"></a>enum <u>FocusMovement</u>: int;
</big></dt>
<dd>focus movement options<br><br>

<dl><dt><big><a name="FocusMovement.None"></a><u>None</u></big></dt>
<dd>no focus movement<br><br>

</dd>
<dt><big><a name="FocusMovement.Next"></a><u>Next</u></big></dt>
<dd>next focusable (Tab)<br><br>

</dd>
<dt><big><a name="FocusMovement.Previous"></a><u>Previous</u></big></dt>
<dd>previous focusable (Shift+Tab)<br><br>

</dd>
<dt><big><a name="FocusMovement.Up"></a><u>Up</u></big></dt>
<dd>move to nearest above<br><br>

</dd>
<dt><big><a name="FocusMovement.Down"></a><u>Down</u></big></dt>
<dd>move to nearest below<br><br>

</dd>
<dt><big><a name="FocusMovement.Left"></a><u>Left</u></big></dt>
<dd>move to nearest at left<br><br>

</dd>
<dt><big><a name="FocusMovement.Right"></a><u>Right</u></big></dt>
<dd>move to nearest at right<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="CursorType"></a>enum <u>CursorType</u>: int;
</big></dt>
<dd>standard mouse cursor types<br><br>

<dl><dt><big><a name="CursorType.Parent"></a><u>Parent</u></big></dt>
<dd>use parent's cursor<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Widget"></a>class <u>Widget</u>;
</big></dt>
<dd>Base class for all widgets.
<br><br>

<dl><dt><big><a name="Widget._id"></a>protected string <u>_id</u>;
</big></dt>
<dd>widget id<br><br>

</dd>
<dt><big><a name="Widget._pos"></a>protected Rect <u>_pos</u>;
</big></dt>
<dd>current widget position, set by layout()<br><br>

</dd>
<dt><big><a name="Widget._visibility"></a>protected Visibility <u>_visibility</u>;
</big></dt>
<dd>widget visibility: either Visible, Invisible, Gone<br><br>

</dd>
<dt><big><a name="Widget._styleId"></a>protected string <u>_styleId</u>;
</big></dt>
<dd>style id to lookup style in theme<br><br>

</dd>
<dt><big><a name="Widget._ownStyle"></a>protected Style <u>_ownStyle</u>;
</big></dt>
<dd>own copy of style - to override some of style properties, <b>null</b> of no properties overriden<br><br>

</dd>
<dt><big><a name="Widget._state"></a>protected uint <u>_state</u>;
</big></dt>
<dd>widget state (set of flags from State enum)<br><br>

</dd>
<dt><big><a name="Widget._measuredWidth"></a>protected int <u>_measuredWidth</u>;
</big></dt>
<dd>width measured by measure()<br><br>

</dd>
<dt><big><a name="Widget._measuredHeight"></a>protected int <u>_measuredHeight</u>;
</big></dt>
<dd>height measured by measure()<br><br>

</dd>
<dt><big><a name="Widget._needLayout"></a>protected bool <u>_needLayout</u>;
</big></dt>
<dd><b>true</b> to force layout<br><br>

</dd>
<dt><big><a name="Widget._needDraw"></a>protected bool <u>_needDraw</u>;
</big></dt>
<dd><b>true</b> to force redraw<br><br>

</dd>
<dt><big><a name="Widget._parent"></a>protected Widget <u>_parent</u>;
</big></dt>
<dd>parent widget<br><br>

</dd>
<dt><big><a name="Widget._window"></a>protected Window <u>_window</u>;
</big></dt>
<dd>window (to be used for top level widgets only!)<br><br>

</dd>
<dt><big><a name="Widget._trackHover"></a>protected bool <u>_trackHover</u>;
</big></dt>
<dd>does widget need to track mouse Hover<br><br>

</dd>
<dt><big><a name="Widget.trackHover"></a>const @property bool <u>trackHover</u>();
</big></dt>
<dd>mouse movement processing flag (when <b>true</b>, widget will change Hover state while mouse is moving)<br><br>

</dd>
<dt><big><a name="Widget.trackHover"></a>@property Widget <u>trackHover</u>(bool <i>v</i>);
</big></dt>
<dd>set new <u>trackHover</u> flag value (when <b>true</b>, widget will change Hover state while mouse is moving)<br><br>

</dd>
<dt><big><a name="Widget.getCursorType"></a>uint <u>getCursorType</u>(int <i>x</i>, int <i>y</i>);
</big></dt>
<dd>returns mouse cursor type for widget<br><br>

</dd>
<dt><big><a name="Widget.this"></a>this(string <i>ID</i> = null);
</big></dt>
<dd>create widget, with optional id<br><br>

</dd>
<dt><big><a name="Widget.style"></a>protected const @property const(Style) <u>style</u>();
</big></dt>
<dd>accessor to <u>style</u> - by lookup in theme by styleId (if <u>style</u> id is not set, theme base <u>style</u> will be used).<br><br>

</dd>
<dt><big><a name="Widget.style"></a>protected const @property const(Style) <u>style</u>(uint <i>stateFlags</i>);
</big></dt>
<dd>accessor to <u>style</u> - by lookup in theme by styleId (if <u>style</u> id is not set, theme base <u>style</u> will be used).<br><br>

</dd>
<dt><big><a name="Widget.stateStyle"></a>protected const @property const(Style) <u>stateStyle</u>();
</big></dt>
<dd>returns style for current widget state<br><br>

</dd>
<dt><big><a name="Widget.ownStyle"></a>protected @property Style <u>ownStyle</u>();
</big></dt>
<dd>enforces widget's own style - allows override some of style properties<br><br>

</dd>
<dt><big><a name="Widget.id"></a>const @property string <u>id</u>();
</big></dt>
<dd>returns widget <u>id</u>, <b>null</b> if not set<br><br>

</dd>
<dt><big><a name="Widget.id"></a>@property Widget <u>id</u>(string <u>id</u>);
</big></dt>
<dd>set widget <u>id</u><br><br>

</dd>
<dt><big><a name="Widget.compareId"></a>const bool <u>compareId</u>(string <i>id</i>);
</big></dt>
<dd>compare widget <i>id</i> with specified value, returs <b>true</b> if matches<br><br>

</dd>
<dt><big><a name="Widget.state"></a>const @property uint <u>state</u>();
</big></dt>
<dd>widget <u>state</u> (set of flags from State enum)<br><br>

</dd>
<dt><big><a name="Widget.handleFocusChange"></a>protected void <u>handleFocusChange</u>(bool <i>focused</i>);
</big></dt>
<dd>override to handle focus changes<br><br>

</dd>
<dt><big><a name="Widget.handleCheckChange"></a>protected void <u>handleCheckChange</u>(bool <i>checked</i>);
</big></dt>
<dd>override to handle check changes<br><br>

</dd>
<dt><big><a name="Widget.state"></a>@property Widget <u>state</u>(uint <i>newState</i>);
</big></dt>
<dd>set new widget <u>state</u> (set of flags from State enum)<br><br>

</dd>
<dt><big><a name="Widget.setState"></a>@property Widget <u>setState</u>(uint <i>stateFlagsToSet</i>);
</big></dt>
<dd>add state flags (set of flags from State enum)<br><br>

</dd>
<dt><big><a name="Widget.resetState"></a>@property Widget <u>resetState</u>(uint <i>stateFlagsToUnset</i>);
</big></dt>
<dd>remove state flags (set of flags from State enum)<br><br>

</dd>
<dt><big><a name="Widget.styleId"></a>const @property string <u>styleId</u>();
</big></dt>
<dd>returns widget style id, <b>null</b> if not set<br><br>

</dd>
<dt><big><a name="Widget.styleId"></a>@property Widget <u>styleId</u>(string <i>id</i>);
</big></dt>
<dd>set widget style <i>id</i><br><br>

</dd>
<dt><big><a name="Widget.margins"></a>const @property Rect <u>margins</u>();
</big></dt>
<dd>get <u>margins</u> (between widget bounds and its background)<br><br>

</dd>
<dt><big><a name="Widget.margins"></a>@property Widget <u>margins</u>(Rect <i>rc</i>);
</big></dt>
<dd>set <u>margins</u> for widget - override one from style<br><br>

</dd>
<dt><big><a name="Widget.padding"></a>const @property Rect <u>padding</u>();
</big></dt>
<dd>get <u>padding</u> (between background bounds and content of widget)<br><br>

</dd>
<dt><big><a name="Widget.padding"></a>@property Widget <u>padding</u>(Rect <i>rc</i>);
</big></dt>
<dd>set <u>padding</u> for widget - override one from style<br><br>

</dd>
<dt><big><a name="Widget.backgroundColor"></a>const @property uint <u>backgroundColor</u>();
</big></dt>
<dd>returns background color<br><br>

</dd>
<dt><big><a name="Widget.backgroundColor"></a>@property Widget <u>backgroundColor</u>(uint <i>color</i>);
</big></dt>
<dd>set background <i>color</i> for widget - override one from style<br><br>

</dd>
<dt><big><a name="Widget.backgroundImageId"></a>const @property string <u>backgroundImageId</u>();
</big></dt>
<dd>background image id<br><br>

</dd>
<dt><big><a name="Widget.backgroundImageId"></a>@property Widget <u>backgroundImageId</u>(string <i>imageId</i>);
</big></dt>
<dd>background image id<br><br>

</dd>
<dt><big><a name="Widget.backgroundDrawable"></a>const @property DrawableRef <u>backgroundDrawable</u>();
</big></dt>
<dd>background drawable<br><br>

</dd>
<dt><big><a name="Widget.alpha"></a>const @property uint <u>alpha</u>();
</big></dt>
<dd>widget drawing <u>alpha</u> value (0=opaque .. 255=transparent)<br><br>

</dd>
<dt><big><a name="Widget.alpha"></a>@property Widget <u>alpha</u>(uint <i>value</i>);
</big></dt>
<dd>set widget drawing <u>alpha</u> <i>value</i> (0=opaque .. 255=transparent)<br><br>

</dd>
<dt><big><a name="Widget.textColor"></a>const @property uint <u>textColor</u>();
</big></dt>
<dd>get text color (ARGB 32 bit value)<br><br>

</dd>
<dt><big><a name="Widget.textColor"></a>@property Widget <u>textColor</u>(uint <i>value</i>);
</big></dt>
<dd>set text color (ARGB 32 bit <i>value</i>)<br><br>

</dd>
<dt><big><a name="Widget.textFlags"></a>@property uint <u>textFlags</u>();
</big></dt>
<dd>get text flags (bit set of TextFlag enum values)<br><br>

</dd>
<dt><big><a name="Widget.textFlags"></a>@property Widget <u>textFlags</u>(uint <i>value</i>);
</big></dt>
<dd>set text flags (bit set of TextFlag enum values)<br><br>

</dd>
<dt><big><a name="Widget.fontFace"></a>const @property string <u>fontFace</u>();
</big></dt>
<dd>returns font face<br><br>

</dd>
<dt><big><a name="Widget.fontFace"></a>@property Widget <u>fontFace</u>(string <i>face</i>);
</big></dt>
<dd>set font <i>face</i> for widget - override one from style<br><br>

</dd>
<dt><big><a name="Widget.fontItalic"></a>const @property bool <u>fontItalic</u>();
</big></dt>
<dd>returns font style (italic/normal)<br><br>

</dd>
<dt><big><a name="Widget.fontItalic"></a>@property Widget <u>fontItalic</u>(bool <i>italic</i>);
</big></dt>
<dd>set font style (<i>italic</i>/normal) for widget - override one from style<br><br>

</dd>
<dt><big><a name="Widget.fontWeight"></a>const @property ushort <u>fontWeight</u>();
</big></dt>
<dd>returns font weight<br><br>

</dd>
<dt><big><a name="Widget.fontWeight"></a>@property Widget <u>fontWeight</u>(ushort <i>weight</i>);
</big></dt>
<dd>set font <i>weight</i> for widget - override one from style<br><br>

</dd>
<dt><big><a name="Widget.fontSize"></a>const @property ushort <u>fontSize</u>();
</big></dt>
<dd>returns font size in pixels<br><br>

</dd>
<dt><big><a name="Widget.fontSize"></a>@property Widget <u>fontSize</u>(ushort <i>size</i>);
</big></dt>
<dd>set font <i>size</i> for widget - override one from style<br><br>

</dd>
<dt><big><a name="Widget.fontFamily"></a>const @property FontFamily <u>fontFamily</u>();
</big></dt>
<dd>returns font family<br><br>

</dd>
<dt><big><a name="Widget.fontFamily"></a>@property Widget <u>fontFamily</u>(FontFamily <i>family</i>);
</big></dt>
<dd>set font <i>family</i> for widget - override one from style<br><br>

</dd>
<dt><big><a name="Widget.alignment"></a>const @property ubyte <u>alignment</u>();
</big></dt>
<dd>returns <u>alignment</u> (combined vertical and horizontal)<br><br>

</dd>
<dt><big><a name="Widget.alignment"></a>@property Widget <u>alignment</u>(ubyte <i>value</i>);
</big></dt>
<dd>sets <u>alignment</u> (combined vertical and horizontal)<br><br>

</dd>
<dt><big><a name="Widget.valign"></a>@property Align <u>valign</u>();
</big></dt>
<dd>returns horizontal alignment<br><br>

</dd>
<dt><big><a name="Widget.halign"></a>@property Align <u>halign</u>();
</big></dt>
<dd>returns vertical alignment<br><br>

</dd>
<dt><big><a name="Widget.font"></a>const @property FontRef <u>font</u>();
</big></dt>
<dd>returns <u>font</u> set for widget using style or set manually<br><br>

</dd>
<dt><big><a name="Widget.text"></a>@property dstring <u>text</u>();
</big></dt>
<dd>returns widget content <u>text</u> (override to support this)<br><br>

</dd>
<dt><big><a name="Widget.text"></a>@property Widget <u>text</u>(dstring <i>s</i>);
</big></dt>
<dd>sets widget content <u>text</u> (override to support this)<br><br>

</dd>
<dt><big><a name="Widget.text"></a>@property Widget <u>text</u>(UIString <i>s</i>);
</big></dt>
<dd>sets widget content <u>text</u> (override to support this)<br><br>

</dd>
<dt><big><a name="Widget.needLayout"></a>@property bool <u>needLayout</u>();
</big></dt>
<dd>returns <b>true</b> if layout is required for widget and its children<br><br>

</dd>
<dt><big><a name="Widget.needDraw"></a>@property bool <u>needDraw</u>();
</big></dt>
<dd>returns <b>true</b> if redraw is required for widget and its children<br><br>

</dd>
<dt><big><a name="Widget.animating"></a>@property bool <u>animating</u>();
</big></dt>
<dd>returns <b>true</b> is widget is being animated - need to call animate() and redraw<br><br>

</dd>
<dt><big><a name="Widget.animate"></a>void <u>animate</u>(long <i>interval</i>);
</big></dt>
<dd>animates window; <i>interval</i> is time left from previous draw, in hnsecs (1/10000000 of second)<br><br>

</dd>
<dt><big><a name="Widget.measuredWidth"></a>@property auto <u>measuredWidth</u>();
</big></dt>
<dd>returns measured width (calculated during measure() call)<br><br>

</dd>
<dt><big><a name="Widget.measuredHeight"></a>@property auto <u>measuredHeight</u>();
</big></dt>
<dd>returns measured height (calculated during measure() call)<br><br>

</dd>
<dt><big><a name="Widget.width"></a>@property int <u>width</u>();
</big></dt>
<dd>returns current <u>width</u> of widget in pixels<br><br>

</dd>
<dt><big><a name="Widget.height"></a>@property int <u>height</u>();
</big></dt>
<dd>returns current <u>height</u> of widget in pixels<br><br>

</dd>
<dt><big><a name="Widget.top"></a>@property int <u>top</u>();
</big></dt>
<dd>returns widget rectangle <u>top</u> position<br><br>

</dd>
<dt><big><a name="Widget.left"></a>@property int <u>left</u>();
</big></dt>
<dd>returns widget rectangle <u>left</u> position<br><br>

</dd>
<dt><big><a name="Widget.pos"></a>@property Rect <u>pos</u>();
</big></dt>
<dd>returns widget rectangle<br><br>

</dd>
<dt><big><a name="Widget.minWidth"></a>@property int <u>minWidth</u>();
</big></dt>
<dd>returns min width constraint<br><br>

</dd>
<dt><big><a name="Widget.maxWidth"></a>@property int <u>maxWidth</u>();
</big></dt>
<dd>returns max width constraint (SIZE_UNSPECIFIED if no constraint set)<br><br>

</dd>
<dt><big><a name="Widget.minHeight"></a>@property int <u>minHeight</u>();
</big></dt>
<dd>returns min height constraint<br><br>

</dd>
<dt><big><a name="Widget.maxHeight"></a>@property int <u>maxHeight</u>();
</big></dt>
<dd>returns max height constraint (SIZE_UNSPECIFIED if no constraint set)<br><br>

</dd>
<dt><big><a name="Widget.maxWidth"></a>@property Widget <u>maxWidth</u>(int <i>value</i>);
</big></dt>
<dd>set max width constraint (SIZE_UNSPECIFIED for no constraint)<br><br>

</dd>
<dt><big><a name="Widget.minWidth"></a>@property Widget <u>minWidth</u>(int <i>value</i>);
</big></dt>
<dd>set max width constraint (0 for no constraint)<br><br>

</dd>
<dt><big><a name="Widget.maxHeight"></a>@property Widget <u>maxHeight</u>(int <i>value</i>);
</big></dt>
<dd>set max height constraint (SIZE_UNSPECIFIED for no constraint)<br><br>

</dd>
<dt><big><a name="Widget.minHeight"></a>@property Widget <u>minHeight</u>(int <i>value</i>);
</big></dt>
<dd>set max height constraint (0 for no constraint)<br><br>

</dd>
<dt><big><a name="Widget.layoutWidth"></a>@property int <u>layoutWidth</u>();
</big></dt>
<dd>returns layout width options (WRAP_CONTENT, FILL_PARENT, or some constant value)<br><br>

</dd>
<dt><big><a name="Widget.layoutHeight"></a>@property int <u>layoutHeight</u>();
</big></dt>
<dd>returns layout height options (WRAP_CONTENT, FILL_PARENT, or some constant value)<br><br>

</dd>
<dt><big><a name="Widget.layoutWeight"></a>@property int <u>layoutWeight</u>();
</big></dt>
<dd>returns layout weight (while resizing to fill parent, widget will be resized proportionally to this value)<br><br>

</dd>
<dt><big><a name="Widget.layoutWidth"></a>@property Widget <u>layoutWidth</u>(int <i>value</i>);
</big></dt>
<dd>sets layout width options (WRAP_CONTENT, FILL_PARENT, or some constant <i>value</i>)<br><br>

</dd>
<dt><big><a name="Widget.layoutHeight"></a>@property Widget <u>layoutHeight</u>(int <i>value</i>);
</big></dt>
<dd>sets layout height options (WRAP_CONTENT, FILL_PARENT, or some constant <i>value</i>)<br><br>

</dd>
<dt><big><a name="Widget.layoutWeight"></a>@property Widget <u>layoutWeight</u>(int <i>value</i>);
</big></dt>
<dd>sets layout weight (while resizing to fill parent, widget will be resized proportionally to this <i>value</i>)<br><br>

</dd>
<dt><big><a name="Widget.visibility"></a>@property Visibility <u>visibility</u>();
</big></dt>
<dd>returns widget <u>visibility</u> (Visible, Invisible, Gone)<br><br>

</dd>
<dt><big><a name="Widget.visibility"></a>@property Widget <u>visibility</u>(Visibility <i>visible</i>);
</big></dt>
<dd>sets widget <u>visibility</u> (Visible, Invisible, Gone)<br><br>

</dd>
<dt><big><a name="Widget.isPointInside"></a>bool <u>isPointInside</u>(int <i>x</i>, int <i>y</i>);
</big></dt>
<dd>returns <b>true</b> if point is inside of this widget<br><br>

</dd>
<dt><big><a name="Widget.enabled"></a>@property bool <u>enabled</u>();
</big></dt>
<dd>return <b>true</b> if state has State.Enabled flag set<br><br>

</dd>
<dt><big><a name="Widget.enabled"></a>@property Widget <u>enabled</u>(bool <i>flg</i>);
</big></dt>
<dd>change <u>enabled</u> state<br><br>

</dd>
<dt><big><a name="Widget.clickable"></a>@property bool <u>clickable</u>();
</big></dt>
<dd>when <b>true</b>, user can click this control, and get onClick listeners called<br><br>

</dd>
<dt><big><a name="Widget.checkable"></a>@property bool <u>checkable</u>();
</big></dt>
<dd>when <b>true</b>, control supports Checked state<br><br>

</dd>
<dt><big><a name="Widget.checked"></a>@property bool <u>checked</u>();
</big></dt>
<dd>get <u>checked</u> state<br><br>

</dd>
<dt><big><a name="Widget.checked"></a>@property Widget <u>checked</u>(bool <i>flg</i>);
</big></dt>
<dd>set <u>checked</u> state<br><br>

</dd>
<dt><big><a name="Widget.focusable"></a>@property bool <u>focusable</u>();
</big></dt>
<dd>whether widget can be focused<br><br>

</dd>
<dt><big><a name="Widget.wantsKeyTracking"></a>@property bool <u>wantsKeyTracking</u>();
</big></dt>
<dd>override and return <b>true</b> to track key events even when not focused<br><br>

</dd>
<dt><big><a name="Widget.focusGroup"></a>@property bool <u>focusGroup</u>();
</big></dt>
<dd>When focus group is set for some parent widget, focus from one of containing widgets can be moved using keyboard only to one of other widgets containing in it and cannot bypass bounds of <u>focusGroup</u>.
<br><br>
If focused widget doesn't have any parent with <u>focusGroup</u> == <b>true</b>, focus may be moved to any focusable within window.<br><br>

</dd>
<dt><big><a name="Widget.focusGroup"></a>@property Widget <u>focusGroup</u>(bool <i>flg</i>);
</big></dt>
<dd>set focus group flag for container widget<br><br>

</dd>
<dt><big><a name="Widget.focusGroupWidget"></a>Widget <u>focusGroupWidget</u>();
</big></dt>
<dd>find nearest parent of this widget with focusGroup flag, returns topmost parent if no focusGroup flag set to any of parents.<br><br>

</dd>
<dt><big><a name="Widget.tabOrder"></a>@property ushort <u>tabOrder</u>();
</big></dt>
<dd>tab order - hint for focus movement using Tab/Shift+Tab<br><br>

</dd>
<dt><big><a name="Widget.visible"></a>@property bool <u>visible</u>();
</big></dt>
<dd>returns <b>true</b> if this widget and all its parents are <u>visible</u><br><br>

</dd>
<dt><big><a name="Widget.canFocus"></a>@property bool <u>canFocus</u>();
</big></dt>
<dd>returns <b>true</b> if widget is focusable and visible<br><br>

</dd>
<dt><big><a name="Widget.setFocus"></a>Widget <u>setFocus</u>();
</big></dt>
<dd>sets focus to this widget or suitable focusable child, returns previously focused widget<br><br>

</dd>
<dt><big><a name="Widget.findFocusableChild"></a>Widget <u>findFocusableChild</u>(bool <i>defaultOnly</i>);
</big></dt>
<dd>searches children for first focusable item, returns <b>null</b> if not found<br><br>

</dd>
<dt><big><a name="Widget.handleAction"></a>bool <u>handleAction</u>(const Action <i>a</i>);
</big></dt>
<dd>override to handle specific actions<br><br>

</dd>
<dt><big><a name="Widget.findKeyAction"></a>protected Action <u>findKeyAction</u>(uint <i>keyCode</i>, uint <i>flags</i>);
</big></dt>
<dd>map key to action<br><br>

</dd>
<dt><big><a name="Widget.onKeyEvent"></a>bool <u>onKeyEvent</u>(KeyEvent <i>event</i>);
</big></dt>
<dd>process key <i>event</i>, return <b>true</b> if <i>event</i> is processed.<br><br>

</dd>
<dt><big><a name="Widget.onMouseEvent"></a>bool <u>onMouseEvent</u>(MouseEvent <i>event</i>);
</big></dt>
<dd>process mouse <i>event</i>; return <b>true</b> if <i>event</i> is processed by widget.<br><br>

</dd>
<dt><big><a name="Widget.onClickListener"></a>Signal!OnClickHandler <u>onClickListener</u>;
</big></dt>
<dd>on click event listener (bool delegate(Widget))<br><br>

</dd>
<dt><big><a name="Widget.onCheckChangeListener"></a>Signal!OnCheckHandler <u>onCheckChangeListener</u>;
</big></dt>
<dd>checked state change event listener (bool delegate(Widget, bool))<br><br>

</dd>
<dt><big><a name="Widget.onFocusChangeListener"></a>Signal!OnFocusHandler <u>onFocusChangeListener</u>;
</big></dt>
<dd>focus state change event listener (bool delegate(Widget, bool))<br><br>

</dd>
<dt><big><a name="Widget.onKeyListener"></a>Signal!OnKeyHandler <u>onKeyListener</u>;
</big></dt>
<dd>key event listener (bool delegate(Widget, KeyEvent)) - return <b>true</b> if event is processed by handler<br><br>

</dd>
<dt><big><a name="Widget.onMouseListener"></a>Signal!OnMouseHandler <u>onMouseListener</u>;
</big></dt>
<dd>mouse event listener (bool delegate(Widget, MouseEvent)) - return <b>true</b> if event is processed by handler<br><br>

</dd>
<dt><big><a name="Widget.addOnClickListener"></a>Widget <u>addOnClickListener</u>(bool delegate(Widget) <i>listener</i>);
</big></dt>
<dd>helper function to add onCheckChangeListener in method chain<br><br>

</dd>
<dt><big><a name="Widget.addOnCheckChangeListener"></a>Widget <u>addOnCheckChangeListener</u>(bool delegate(Widget, bool) <i>listener</i>);
</big></dt>
<dd>helper function to add onCheckChangeListener in method chain<br><br>

</dd>
<dt><big><a name="Widget.addOnFocusChangeListener"></a>Widget <u>addOnFocusChangeListener</u>(bool delegate(Widget, bool) <i>listener</i>);
</big></dt>
<dd>helper function to add onFocusChangeListener in method chain<br><br>

</dd>
<dt><big><a name="Widget.requestLayout"></a>void <u>requestLayout</u>();
</big></dt>
<dd>request relayout of widget and its children<br><br>

</dd>
<dt><big><a name="Widget.invalidate"></a>void <u>invalidate</u>();
</big></dt>
<dd>request redraw<br><br>

</dd>
<dt><big><a name="Widget.measuredContent"></a>protected void <u>measuredContent</u>(int <i>parentWidth</i>, int <i>parentHeight</i>, int <i>contentWidth</i>, int <i>contentHeight</i>);
</big></dt>
<dd>helper function for implement measure() when widget's content dimensions are known<br><br>

</dd>
<dt><big><a name="Widget.measure"></a>void <u>measure</u>(int <i>parentWidth</i>, int <i>parentHeight</i>);
</big></dt>
<dd>Measure widget according to desired width and height constraints. (Step 1 of two phase layout).
<br><br>

</dd>
<dt><big><a name="Widget.layout"></a>void <u>layout</u>(Rect <i>rc</i>);
</big></dt>
<dd>Set widget rectangle to specified value and <u>layout</u> widget contents. (Step 2 of two phase <u>layout</u>).<br><br>

</dd>
<dt><big><a name="Widget.onDraw"></a>void <u>onDraw</u>(DrawBuf <i>buf</i>);
</big></dt>
<dd>Draw widget at its position to buffer<br><br>

</dd>
<dt><big><a name="Widget.applyMargins"></a>void <u>applyMargins</u>(ref Rect <i>rc</i>);
</big></dt>
<dd>Helper function: applies margins to rectangle<br><br>

</dd>
<dt><big><a name="Widget.applyPadding"></a>void <u>applyPadding</u>(ref Rect <i>rc</i>);
</big></dt>
<dd>Helper function: applies padding to rectangle<br><br>

</dd>
<dt><big><a name="Widget.applyAlign"></a>static void <u>applyAlign</u>(ref Rect <i>rc</i>, Point <i>sz</i>, Align <i>ha</i>, Align <i>va</i>);
</big></dt>
<dd>Applies alignment for content of size <i>sz</i> - set rectangle <i>rc</i> to aligned value of content inside of initial value of <i>rc</i>.<br><br>

</dd>
<dt><big><a name="Widget.applyAlign"></a>void <u>applyAlign</u>(ref Rect <i>rc</i>, Point <i>sz</i>);
</big></dt>
<dd>Applies alignment for content of size <i>sz</i> - set rectangle <i>rc</i> to aligned value of content inside of initial value of <i>rc</i>.<br><br>

</dd>
<dt><big><a name="Widget.canShowPopupMenu"></a>bool <u>canShowPopupMenu</u>(int <i>x</i>, int <i>y</i>);
</big></dt>
<dd>returns <b>true</b> if widget can show popup menu (e.g. by mouse right click at point <i>x</i>,<i>y</i>)<br><br>

</dd>
<dt><big><a name="Widget.showPopupMenu"></a>void <u>showPopupMenu</u>(int <i>x</i>, int <i>y</i>);
</big></dt>
<dd>shows popup menu at (<i>x</i>,<i>y</i>)<br><br>

</dd>
<dt><big><a name="Widget.isActionEnabled"></a>bool <u>isActionEnabled</u>(const Action <i>action</i>);
</big></dt>
<dd>override to change popup menu items state<br><br>

</dd>
<dt><big><a name="Widget.childCount"></a>@property int <u>childCount</u>();
</big></dt>
<dd>returns number of children of this widget<br><br>

</dd>
<dt><big><a name="Widget.child"></a>Widget <u>child</u>(int <i>index</i>);
</big></dt>
<dd>returns <u>child</u> by <i>index</i><br><br>

</dd>
<dt><big><a name="Widget.addChild"></a>Widget <u>addChild</u>(Widget <i>item</i>);
</big></dt>
<dd>adds child, returns added <i>item</i><br><br>

</dd>
<dt><big><a name="Widget.removeChild"></a>Widget <u>removeChild</u>(int <i>index</i>);
</big></dt>
<dd>removes child, returns removed item<br><br>

</dd>
<dt><big><a name="Widget.removeChild"></a>Widget <u>removeChild</u>(string <i>id</i>);
</big></dt>
<dd>removes child by ID, returns removed item<br><br>

</dd>
<dt><big><a name="Widget.childIndex"></a>int <u>childIndex</u>(Widget <i>item</i>);
</big></dt>
<dd>returns index of widget in child list, -1 if passed widget is not a child of this widget<br><br>

</dd>
<dt><big><a name="Widget.isChild"></a>bool <u>isChild</u>(Widget <i>item</i>, bool <i>deepSearch</i> = true);
</big></dt>
<dd>returns <b>true</b> if <i>item</i> is child of this widget (when <i>deepSearch</i> == <b>true</b> - returns <b>true</b> if <i>item</i> is this widget or one of children inside children tree).<br><br>

</dd>
<dt><big><a name="Widget.childById"></a>Widget <u>childById</u>(string <i>id</i>, bool <i>deepSearch</i> = true);
</big></dt>
<dd>find child by <i>id</i>, returns <b>null</b> if not found<br><br>

</dd>
<dt><big><a name="Widget.parent"></a>@property Widget <u>parent</u>();
</big></dt>
<dd>returns <u>parent</u> widget, <b>null</b> for top level widget<br><br>

</dd>
<dt><big><a name="Widget.parent"></a>@property Widget <u>parent</u>(Widget <u>parent</u>);
</big></dt>
<dd>sets <u>parent</u> for widget<br><br>

</dd>
<dt><big><a name="Widget.window"></a>@property Window <u>window</u>();
</big></dt>
<dd>returns <u>window</u> (if widget or its parent is attached to <u>window</u>)<br><br>

</dd>
<dt><big><a name="Widget.window"></a>@property void <u>window</u>(Window <u>window</u>);
</big></dt>
<dd>sets <u>window</u> (to be used for top level widget from Window implementation). TODO: hide it from API?<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ObjectList"></a>struct <u>ObjectList</u>(T);
</big></dt>
<dd>object list holder, owning its objects - on destroy of holder, all own objects will be destroyed<br><br>

<dl><dt><big><a name="ObjectList.count"></a>const @property int <u>count</u>();
</big></dt>
<dd>returns <u>count</u> of items<br><br>

</dd>
<dt><big><a name="ObjectList.get"></a>T <u>get</u>(int <i>index</i>);
</big></dt>
<dd><u>get</u> item by <i>index</i><br><br>

</dd>
<dt><big><a name="ObjectList.add"></a>T <u>add</u>(T <i>item</i>);
</big></dt>
<dd><u>add</u> <i>item</i> to list<br><br>

</dd>
<dt><big><a name="ObjectList.insert"></a>T <u>insert</u>(T <i>item</i>, int <i>index</i> = -1);
</big></dt>
<dd>add <i>item</i> to list<br><br>

</dd>
<dt><big><a name="ObjectList.indexOf"></a>int <u>indexOf</u>(T <i>item</i>);
</big></dt>
<dd>find child index for <i>item</i>, return -1 if not found<br><br>

</dd>
<dt><big><a name="ObjectList.indexOf"></a>int <u>indexOf</u>(string <i>id</i>);
</big></dt>
<dd>find child index for item by <i>id</i>, return -1 if not found<br><br>

</dd>
<dt><big><a name="ObjectList.remove"></a>T <u>remove</u>(int <i>index</i>);
</big></dt>
<dd><u>remove</u> item from list, return removed item<br><br>

</dd>
<dt><big><a name="ObjectList.replace"></a>void <u>replace</u>(T <i>item</i>, int <i>index</i>);
</big></dt>
<dd>Replace <i>item</i> with another value, destroy old value.<br><br>

</dd>
<dt><big><a name="ObjectList.clear"></a>void <u>clear</u>();
</big></dt>
<dd>remove and destroy all items<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="WidgetList"></a>alias <u>WidgetList</u> = ObjectList!(Widget).ObjectList;
</big></dt>
<dd>Widget list holder.<br><br>

</dd>
<dt><big><a name="WidgetGroup"></a>class <u>WidgetGroup</u>: <u>dlangui.widgets.widget.Widget</u>;
</big></dt>
<dd>Base class for widgets which have children.<br><br>

<dl><dt><big><a name="WidgetGroup.childCount"></a>@property int <u>childCount</u>();
</big></dt>
<dd>returns number of children of this widget<br><br>

</dd>
<dt><big><a name="WidgetGroup.child"></a>Widget <u>child</u>(int <i>index</i>);
</big></dt>
<dd>returns <u>child</u> by <i>index</i><br><br>

</dd>
<dt><big><a name="WidgetGroup.addChild"></a>Widget <u>addChild</u>(Widget <i>item</i>);
</big></dt>
<dd>adds child, returns added <i>item</i><br><br>

</dd>
<dt><big><a name="WidgetGroup.removeChild"></a>Widget <u>removeChild</u>(int <i>index</i>);
</big></dt>
<dd>removes child, returns removed item<br><br>

</dd>
<dt><big><a name="WidgetGroup.removeChild"></a>Widget <u>removeChild</u>(string <i>ID</i>);
</big></dt>
<dd>removes child by <i>ID</i>, returns removed item<br><br>

</dd>
<dt><big><a name="WidgetGroup.childIndex"></a>int <u>childIndex</u>(Widget <i>item</i>);
</big></dt>
<dd>returns index of widget in child list, -1 if passed widget is not a child of this widget<br><br>

</dd>
</dl>
</dd>
</dl>

            </section>
            <footer>
              Dlangui is maintained by <a href="https://github.com/buggins">buggins</a><br>
              This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
            </footer>
         
          </div>
        </div>
      </body>
    </html>	
